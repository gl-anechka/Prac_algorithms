// Задача 03-23: Правильная пирамида
// Правильная пирамида на координатной плоскости определяется следующими условиями.
// Такая пирамида состоит из ярусов, расположенных один над другим. Каждый ярус должен
// состоять из квадратных блоков одинакового размера, расположенных в одну линию.
// Длиной соответствующего яруса называется произведение размера блока и числа блоков
// в ярусе. В правильной пирамиде, длина всех ярусов кроме яруса-основания строго меньше
// длины всех нижележащих ярусов. Кроме того, в такой пирамиде каждый вышележащий ярус
// содержит на один блок меньше, чем нижележащий ярус, и такая пирамида всегда в вершине
// имеет ярус из одного блока. Требуется выяснить, можно ли из заданного набора блоков
// построить правильную пирамиду, используя все заданные блоки.
// На стандартном потоке ввода задается натуральное число M (M < 19) и далее M пар натуральных
// чисел Si, Ci, где Si - размер стороны блока (Si < 10000), Ci - количество блоков размера SxS,
// причем Si < Si+1 для всех допустимых i. Известно также, что сумма всех Ci < 200.
// На стандартный поток вывода напечатайте "Yes", если правильную пирамиду можно построить,
// и "No" в противном случае.

#include <stdio.h>

int blocks[19][2];  // блоки (дано)
int blocks_use[19];  // блоки, для использования
int pir_rows[19];  // сборка пирамиды (хранит размеры блоков)


// Первый параметр - кол-во блоков в текущем ряду
// Второй параметр - кол-во блоков нижнего яруса
// Третий параметр - кол-во разных по размеру блоков (дано)

// Собираем пирамиду сверху вниз, т. е. от 1 до n
int piramid(int r, int n, int m)
{
  for (int i = 0; i < m; i++)
  {
    if (blocks_use[i] <= r)
    {
      continue;
    }

    // Проверка правильности пирамиды (длина нового ряда > предыдушего)
    if (blocks[i][0] * (r + 1) > pir_rows[r - 1] * r)
    {
      pir_rows[r] = blocks[i][0];
      blocks_use[i] -= r + 1;

      if (r + 1 == n)
      {
        return 1;
      }
      if (piramid(r + 1, n, m) == 1)
      {
        return 1;
      }

      blocks_use[i] += r + 1;
    }
  }

  return 0;
}



int main(void)
{
  int m;
  scanf("%d", &m);

  int count = 0;  // количество всех блоков
  int n = 1;  // подсчет арифм. прогрессии
              // после подсчета - кол-во блоков нижнего яруса

  for (int i = 0; i < m; i++)
  {
    scanf("%d%d", &blocks[i][0], &blocks[i][1]);
    blocks_use[i] = blocks[i][1];
    count += blocks[i][1];
  }

  // Блоки пирамиды составляют арифметичекую прогрессию
  // 1 2 3 4 ... n
  // Можно сразу проверить это условие
  while (2 * count > n * (n + 1))
  {
    n++;
  }

  if (2 * count != n * (n + 1))
  {
    printf("No");
  }
  else
  {
    if (piramid(0, n, m) == 1)
    {
      printf("Yes");
    }
    else
    {
      printf("No");
    }
  }

  return 0;
}